#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# =============================================================================
# Created By  : Martin Timms
# Created Date: Thursday 3rd February 2022
# Project: https://github.com/Electro-resonance/circular-lspr-slide-rule
# Description: Circular Lograithmic Slide Rule for Physical Constants
# Extended to angular displays for geometric exploration using 
# 2 ATAN(Ln(_)/19 SQRT(2))
# =============================================================================

# =============================================================================
# Package requirements:
# =============================================================================
#python3.7
#sudo easy_install-3.7 pygame
#sudo easy_install-3.7 pyopengl

# =============================================================================
# Useful Links
# =============================================================================
# Colour chart: https://htmlcolorcodes.com/color-chart/material-design-color-chart/
# OpenGL intro: https://stackabuse.com/brief-introduction-to-opengl-in-python-with-pyopengl/
# CSV reader: https://docs.python.org/3/library/csv.html
# Circle examples: https://stackoverflow.com/questions/25423268/i-have-created-a-circle-from-lines-in-opengl-but-it-shows-holes-at-outer-edges
# Mouse with OpenGL: https://stackoverflow.com/questions/46801701/how-to-find-pygame-window-coordinates-of-an-opengl-vertice

# =============================================================================
# Imports
# =============================================================================
import pygame
from pygame.locals import *
from OpenGL.GL import *
from OpenGL.GLU import *
from OpenGL.GLUT import *
import math
import sys
import csv


# =============================================================================
# Global variables
# =============================================================================
debug=False

demo_mode=False
log_mode=False
factor=19*math.sqrt(2)
constants=[]

math_e=math.exp(1)
math_phi=(1+math.sqrt(5))/2
pi=math.pi

zooming=True
zoom_distance=-50

mpos = [0,0]
viewPos = [0,0]
mouse_radial = [0,0]
mouse_hold_pos = [0,0]
mouse_button = [0,0,0]
prev_mouse_button =[0,0,0]

zoom_pos=[0,0,-100]
zoom_set=[0,0,-50]

rotation = 0.0

# =============================================================================
# CSV Reader Function                                 
# ============================================================================= 

def read_csv():
  global constants
  constants=[]
  with open('constants.csv', 'r', newline='',encoding='utf16') as csvfile:
     reader = csv.DictReader(csvfile)

     #Read lines from the csv file
     for row in reader:
        const_name=row['description']
        log_const=float(row['log'])
        symbol=row['symbol'].strip()
        geo=row['geometry']
        print(const_name,log_const,geo,symbol,len(symbol))

        if geo and geo.isdigit():
           geometry=float(row['geometry'])
        else:
           geometry=0

        if log_mode==False:
            angle=2 * math.atan(log_const/factor)
            angle_deg=angle/math.pi*180
        else:
            angle_deg=log_const/factor
            if(const_name.find("+/- Infinity")!=-1):
                angle_deg=180

        #Colours based on angle of the constants
        const_colour=[0.2,0.2,0.2]
        if (int((angle_deg+0.001)/72)):
           const_colour[2]=0.1
        else:
           const_colour[2]=0.0
        if (int((angle_deg+0.001)/90)):
           const_colour[0]=0.5
        else:
           const_colour[0]=0

        #Find some keywords and add colours related to the constant type
        if (const_name.find("eed")!=-1):#"Speed"
           const_colour=[1,1,1]
        if (const_name.find("Electric")!=-1):
           const_colour=[1,0,1]
        if (const_name.find("Gravit")!=-1):
           const_colour=[0,1,1]
        if (const_name.find("Period")!=-1 or const_name.find("Frequency")!=-1 or int(angle_deg*10)==0):
           const_colour=[1,1,0]
        if (geometry>0):
           const_colour=[0.9,0.9,0.9]

        source=row['source']
        value=row['value']
        uncertainty=row['uncertainty']
        units=row['unit']
        category=row['category']
        subcategory=row['subcategory']

        #Create a list of constants
        const=(const_name,log_const,angle_deg,const_colour,geometry,symbol,source,value,uncertainty,units,category,subcategory)
        constants.append(const)

# =============================================================================
# Misc Functions
# =============================================================================

def angle_difference(a,b):
   while b<-180:
      b+=360
   return min(360 - abs(a - b), abs(a - b))

def angle_movement(a,b):
   while b<-180:
      b+=360
   diff=a-b
   if abs(diff)>90:
      diff=0
   return diff

# =============================================================================
# Constant List Modification Function
# =============================================================================

def adjust_factors():
    for idx in range(len(constants)):
        (const_name,log_const,angle_deg,const_colour,geometry,symbol,source,value,uncertainty,units,category,subcategory)= constants[idx]
        if log_mode==False:
            angle=2 * math.atan(log_const/factor)
            angle_deg=angle/math.pi*180
        else:
            angle_deg=log_const/factor
            if(const_name.find("+/- Infinity")!=-1):
                angle_deg=180
        constants[idx]=(const_name,log_const,angle_deg,const_colour,geometry,symbol,source,value,uncertainty,units,category,subcategory)

 
# =============================================================================
# 3D Text Printing Functions   
# =============================================================================

def drawText(x, y, text,pts):
    font = pygame.font.SysFont('arial', pts)                                                
    textSurface = font.render(text, True, (255, 255, 66, 255)).convert_alpha()
    textData = pygame.image.tostring(textSurface, "RGBA", True)
    glWindowPos2d(x, y)
    glDrawPixels(textSurface.get_width(), textSurface.get_height(), GL_RGBA, GL_UNSIGNED_BYTE, textData)
       

def drawTextRadialRaster(r,angle, text):
    x = r * math.cos(angle/180*math.pi)
    y = r * math.sin(angle/180*math.pi)
    textSurface = font.render(text, True, (255, 255, 66, 255)).convert_alpha()
    textData = pygame.image.tostring(textSurface, "RGBA", True)
    glRasterPos(x,y)
    glDrawPixels(textSurface.get_width(), textSurface.get_height(), GL_RGBA, GL_UNSIGNED_BYTE, textData)

def label(x, y, s, angle, dir, scale,colour):
     glPushMatrix()
     glColor(colour)
     glTranslatef(x, y, 0.0)
     glScalef(scale, scale, scale)
     glRotatef(angle, 0, 0, 1);
     for c in s:
         glutStrokeCharacter(GLUT_STROKE_ROMAN, ord(c))
         width=glutStrokeWidth(GLUT_STROKE_ROMAN, ord(c))
     glPopMatrix()

def label_length(s):
     str_len=0
     for c in s:
        str_len+=glutStrokeWidth(GLUT_STROKE_ROMAN, ord(c))
     return str_len

def drawTextRadial(r,angle, text,scale,colour):
    text_angle=angle
    dir=0
    if (angle>90 or angle<-90):
         text_angle-=180
         dir=1
         len=label_length(text)
         r+=len*scale
    x = r * math.cos(angle/180*math.pi)
    y = r * math.sin(angle/180*math.pi)
    label(x, y, text, text_angle, dir, scale,colour)


# =============================================================================
# 3D Drawing Functions  
# =============================================================================

def draw_radial(r1,r2, h, num_slices,width,offset,colour,ang_width):
    n = float(num_slices)

    z = -h/2.0
    angle = offset/180*math.pi
    width1=ang_width/180*math.pi
    #angle-=width1/2 #centre the angle  y offsetting the rectangle
    for i in range(int(n)):
        angle = 2 * math.pi * (i/n)/width + offset/180*math.pi
        x1 = r1 * math.cos(angle + width1)
        y1 = r1 * math.sin(angle + width1)
        x2 = r1 * math.cos(angle)
        y2 = r1 * math.sin(angle)
        x3 = r2 * math.cos(angle)
        y3 = r2 * math.sin(angle)
        x4 = r2 * math.cos(angle + width1) 
        y4 = r2 * math.sin(angle + width1)

        glBegin(GL_QUADS)#draw a quadrangle for the radial arm
        glColor(colour)
        glVertex(x1, y1, z)
        glVertex(x2, y2, z)
        glVertex(x3, y3, z)
        glVertex(x4, y4, z)
        glVertex(x1, y1, z)
        glEnd()

def draw_circle(r1,r2, h, num_slices,width,offset,colour):
    n = float(num_slices)

    glBegin(GL_TRIANGLE_FAN)#draw the circle
    glColor(colour)
    z = -h/2.0
    for i in range(int(n) + 1):
        angle = 2 * math.pi * (i/n)
        x1 = r1 * math.cos(angle)
        y1 = r1 * math.sin(angle)
        x2 = r2 * math.cos(angle)
        y2 = r2 * math.sin(angle)
        glVertex(x2, y2, z)
    glEnd()


# =============================================================================
# Mouse Control
# =============================================================================

def check_mouse():
    global mpos, viewPos , mouse_radial, mouse_button, rotation, mouse_hold_pos, rotate, zoom_distance
    global prev_mouse_button
    changed=False
    newpos = pygame.mouse.get_pos()
    if (newpos[0]!=mpos[0] or newpos[1]!=mpos[1]):
       mpos=newpos
       z = 31
       ndc = [ 2.0 * mpos[0]/width - 1.0, 1.0 - 2.0 * mpos[1]/height ]
       tanFov = math.tan( zoom_distance * 0.5 * math.pi / 180 )
       aspect = width / height
       viewPos = [z * ndc[0] * aspect * tanFov + zoom_set[0] , z * ndc[1] * tanFov +zoom_set[1]]
       mouse_ang=180*math.atan2(viewPos[0],-viewPos[1])/math.pi+90
       if (mouse_ang>180):
           mouse_ang=mouse_ang-360
       mouse_radial = [ math.sqrt(viewPos[0]*viewPos[0]+viewPos[1]*viewPos[1]) , mouse_ang ]
       changed=True
    
    mouse_button = pygame.mouse.get_pressed()
    #Ignore the initial mouse press
    if (mouse_button[0]==True and prev_mouse_button[0]==True):
       rotation-=angle_movement(mouse_radial[1],mouse_hold_pos[1])*5
       mouse_hold_pos=mouse_radial
       rotate=0
       changed=True
    else:
       mouse_hold_pos=mouse_radial
    if (mouse_button[2]==True):
       zoom_distance=zoom_distance+angle_movement(mouse_radial[1],mouse_hold_pos[1])/2
       if(zoom_distance>-8):
          zoom_distance=-8
       elif (zoom_distance<-99):
          zoom_distance=-99
       mouse_hold_pos=mouse_radial
       changed=True
    prev_mouse_button=mouse_button
    return changed

# =============================================================================
# Update screen
# =============================================================================

def update_zoom():
   global zoom_set , zoom_pos, zooming, mouse_radial
   if (zoom_location==-1000):
        #move back far enough to see this object
        zoom_set=[0,0,-50]
   else:
        zoom_radius=10
        zoom_angle=zoom_location
        zoom_set = [zoom_radius * math.cos(zoom_angle/180*math.pi) , zoom_radius * math.sin(zoom_angle/180*math.pi) , zoom_distance]

   zooming=False
   dist=0
   for dimension in range(3):
        if (zoom_pos[dimension]!=zoom_set[dimension]):
            zooming=True #Flag that we are still zooming
        zoom_pos[dimension]=(7*zoom_pos[dimension]+zoom_set[dimension])/8 #Weighted rolling averageÂ§
        dist+=abs(zoom_pos[dimension]-zoom_set[dimension]) #Add up amount of movement needed

   #Check if we are nearly at destination zoom position
   if dist<0.01:
       zoom_pos=zoom_set

   glTranslate(zoom_pos[0], zoom_pos[1], zoom_pos[2])

def update_display():
    global mpos, mouse_radial, viewPos
    glClear(GL_COLOR_BUFFER_BIT)
    glClear(GL_DEPTH_BUFFER_BIT)
    glEnable(GL_DEPTH_TEST)

    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(30, float(width)/height, 1, 100)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    update_zoom()

    #TODO: This is the factor used for ATAN mode.
    #Needs a more meaningful display
    drawText(20,40,str(factor) ,14)
    drawText(20,20,str(zoom_distance) ,14)


    if (debug):
        drawText(20,70,str(round(mouse_radial[0],3)) )
        drawText(20,90,str(round(mouse_radial[1],2)) )
        drawText(20,110,str(mpos[0]) )
        drawText(20,130,str(mpos[1]) )
        #drawText(20,140,str(viewPos[0]) )
        #drawText(20,160,str(viewPos[1]) )

    if(log_mode==False):
       intensity=500
       #Draw geometric shapes for the ATAN scales to investigate angular alignments.
       draw_circle(1,8,0.1,3,360,5,[106/intensity,27/intensity,154/intensity])#TRIANGLE
       draw_circle(1,8,0.2,4,360,5,[0/intensity,150/intensity,136/intensity])#SQUARE
       draw_circle(1,8,0.3,5,360,5,[158/intensity,157/intensity,36/intensity])#PENTAGON
       draw_circle(1,8,0.4,7,360,5,[51/intensity, 105/intensity, 30/intensity])#HEPTAGON
    else:
     #Draw a pointer when in log mode
     glPushMatrix()
     glTranslatef(7, 0, 0.0)
     draw_circle(1,1,0.1,3,360,5,[1,1,1])#TRIANGLE
     glPopMatrix()

    draw_circle(1,8,0.4,7,360,5,[0.1,0,0.1])#Octagon Inner Background
    draw_circle(12,13.5,0.5,11,360,5,[0.1,0,0.1])#Hendecagon Outer Background


    slice=1
    hght=0.2
    wd=800
    overlap=0.05

    mouse_ang_width=0.6

    if (not log_mode):
        #Marker for 23 degrees which is maximum angle for polarisation entanglement
        draw_radial(13,15,hght,30,wd,23+120,[1,1,0],0.5)
        draw_radial(13,15,hght,30,wd,120,[1,1,0],0.5)
        #Marker for 23 degrees which is maximum angle for polarisation entanglement
        draw_radial(13,15,hght,30,wd,90,[1,1,0],0.5)
        draw_radial(13,15,hght,30,wd,90+23,[1,1,0],0.5)

    detail_offset=150

    for (const_name,log_const,angle_deg,const_colour,geometry,symbol,source,value,uncertainty,units,category,subcategory) in constants:
       if (disp_symbol==0 or ((disp_symbol==1 or disp_symbol==3) and len(symbol)>0)):
           draw_radial(8,10+overlap,hght,slice,wd,angle_deg-rotation/5,const_colour,0.5)
           draw_radial(10-overlap,12,hght,slice,wd,angle_deg,const_colour,0.5)
           draw_radial(9,10+overlap,hght,slice,wd,angle_deg-rotation/5,const_colour,0.5)
           #Detect mouse over constant
           draw_text=False
           if(mouse_radial[0]>=5 and mouse_radial[0]<10):
              if(angle_difference(mouse_radial[1],(angle_deg-rotation/5))<mouse_ang_width):
                 draw_text=True
           if(mouse_radial[0]>=10 and mouse_radial[0]<14):
              if(angle_difference(mouse_radial[1],angle_deg)<mouse_ang_width):
                 draw_text=True
           
           if (draw_text==True):
              drawText(20,detail_offset,value+ " " + units,20)
              if (symbol in const_name):
                  symbol=""
              drawText(20,detail_offset+30,const_name+ "    " +symbol,20) 
              drawText(20,detail_offset+60,"Source: " +source,12)
              detail_offset+=100

       if(geometry>0 and geometry<6):
          drawTextRadialRaster(12.5,angle_deg, const_name)
          rad_len=13
       else:
          rad_len=12

       if (zoom_location>-1000 or disp_symbol==3):
          text_offset=0.3
          if (disp_symbol!=0):
              drawTextRadial(12+text_offset,angle_deg, symbol,0.0015,yellow)
              drawTextRadial(10+text_offset,angle_deg-rotation/5,symbol,0.0015,yellow)
          #else:
              #drawTextRadial(12+text_offset,angle_deg, const_name,0.0015,yellow)
              #drawTextRadial(10+text_offset,angle_deg-rotation/5, const_name,0.0015,yellow)

      
       if (disp_symbol==0 or ((disp_symbol==1 or disp_symbol==3) and len(symbol)>0)):
          #Draw outer circle
          draw_radial(11-overlap,rad_len,hght,slice,wd,angle_deg,const_colour,0.5)

    pygame.display.flip()

# =============================================================================
# Help Banner
# =============================================================================

def print_help():
   print("** Circular logarithmic slide rule for fundamental physical constants **")
   print()
   print(" z,x = rotate the inner slide rule wheel")
   print(" c,d = zoom in/out")
   print(" q = return to 0 degree rotation point")
   print(" w = return to -180 degree rotation point")
   print(" e = cancel zoom")
   print(" 1,2,3,4,5,6,7,8,9,0 = zoom on sectors of the circular slide rule")

   print(" f = display basic symbols")
   print(" g = display all symbols")
   print(" h = display basic symbols when not zoomed")
   print(" a = natural log mode")
   print(" s = arctangent natural log mode")
   print()
   print(" r,t,y,u,i - experimental arc tangent scaling factors")
   print(" h,j,k,l - experimental natural log scaling factors")
   print(" v,b - demo modes")


   print(" ")
   print(" k,l = course adjust factor for ARCTAN scaling")
   print(" n,m = fine adjust factor for ARCTAN scaling")

# =============================================================================
# Main Code
# =============================================================================

read_csv() # Read the fundamental constants into a list
print_help()

pygame.init()
(width, height) = (1080,800) #(800, 600)
screen = pygame.display.set_mode((width, height), OPENGL | DOUBLEBUF)
clock = pygame.time.Clock()
font = pygame.font.SysFont('arial', 12)
glEnable(GL_BLEND)
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

rotate=1
zoom_location=-1000
disp_symbol=1
yellow=[1,1,0]

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

    keypress = pygame.key.get_pressed()
    req_update=True

    prev_zoom_location=zoom_location

    #TODO: This becomes a case statement in Python3.10
    if keypress[pygame.K_z]:
       rotation += 1.0
       rotate=0
    elif keypress[pygame.K_x]:
       rotation -= 1.0
       rotate=0
    elif keypress[pygame.K_q]:
       rotation = 0.0
       rotate=0
       zoom_distance=-50
       zoom_location=-1000
    elif keypress[pygame.K_w]:
       rotation = 180.0*5
       rotate=0
       zoom_distance=-50
       zoom_location=-1000
    elif keypress[pygame.K_e]:
       zoom_distance=-50
       zoom_location=-1000
    elif keypress[pygame.K_s]:
       demo_mode=False
       factor=19*math.sqrt(2)
       log_mode=False
       adjust_factors()
    elif keypress[pygame.K_r]:
       factor=9.5*math.sqrt(2)
       log_mode=False
       adjust_factors()
    elif keypress[pygame.K_t]:
       factor=19*math.sqrt(2)
       log_mode=False
       adjust_factors()
    elif keypress[pygame.K_y]:
       factor=57.206
       log_mode=False
       adjust_factors()
    elif keypress[pygame.K_u]:
       factor=(30)*math.sqrt(5)
       log_mode=False
       adjust_factors()
    elif keypress[pygame.K_i]:
       factor=82.37
       log_mode=False
       adjust_factors()
    elif keypress[pygame.K_a]:
       log_mode=True
       demo_mode=False
       factor=1.0
       adjust_factors()
    elif keypress[pygame.K_h]:
       log_mode=True
       factor=0.75
       adjust_factors()
    elif keypress[pygame.K_j]:
       log_mode=True
       factor=1/math.sqrt(2)
       adjust_factors()
    elif keypress[pygame.K_k]:
       log_mode=True
       factor=1/math_phi
       adjust_factors()
    elif keypress[pygame.K_l]:
       log_mode=True
       factor=0.5
       adjust_factors()
    elif keypress[pygame.K_k]:
       factor+=0.1
       adjust_factors()
    elif keypress[pygame.K_l]:
       factor-=0.1
       adjust_factors()
    elif keypress[pygame.K_n]:
       factor+=0.01
       adjust_factors()
    elif keypress[pygame.K_m]:
       factor-=0.01
       adjust_factors()
    elif keypress[pygame.K_1]:
       zoom_location=0
    elif keypress[pygame.K_2]:
       zoom_location=30
    elif keypress[pygame.K_3]:
       zoom_location=-30
    elif keypress[pygame.K_4]:
       zoom_location=90
    elif keypress[pygame.K_5]:
       zoom_location=-90
    elif keypress[pygame.K_6]:
       zoom_location=120
    elif keypress[pygame.K_7]:
       zoom_location=-120
    elif keypress[pygame.K_8]:
       zoom_location=144
    elif keypress[pygame.K_9]:
       zoom_location=-144
    elif keypress[pygame.K_0]:
       zoom_location=180
    elif keypress[pygame.K_f]:
       disp_symbol=0
    elif keypress[pygame.K_g]:
       disp_symbol=1
    elif keypress[pygame.K_h]:
       disp_symbol=3
    elif keypress[pygame.K_v]:
       demo_mode=True
       rotate=1
    elif keypress[pygame.K_b]:
       demo_mode=False
       rotate=0
    elif keypress[pygame.K_d]:
       if (zoom_location!=-1000):
          zoom_distance=zoom_distance+1
          if(zoom_distance>-8):
             zoom_distance=-8
       else:
          zoom_location=180
    elif keypress[pygame.K_c]:
       if (zoom_location!=-1000):
          zoom_distance=zoom_distance-1
          if(zoom_distance<-99):
             zoom_distance=-99
       else:
          zoom_location=180
    else:
       #Only rotate if no keys pressed
       rotation += rotate
       if (int(rotate*1000)!=0):
         req_update=True
       else:
         req_update=False

    #Focus after a zoom change
    if (zoom_location!=prev_zoom_location):
        zoom_distance=-20

    if (check_mouse()):
       req_update=True

    if (req_update or zooming):
       update_display()

    clock.tick(60)
    pygame.event.pump() # process event queue
