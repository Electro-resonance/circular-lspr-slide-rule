#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# =============================================================================
# Created By  : Martin Timms
# Created Date: Thursday 3rd February 2022
# Project: https://github.com/Electro-resonance/circular-lspr-slide-rule
# Description: Circular Lograithmic Slide Rule for Physical Constants
# Extended to angular displays for geometric exploration using 
# 2 ATAN(Ln(_)/19 SQRT(2))
# =============================================================================

# =============================================================================
# Package requirements:
# =============================================================================
#python3.7
#sudo easy_install-3.7 pygame
#sudo easy_install-3.7 pyopengl

# =============================================================================
# Useful Links
# =============================================================================
# Colour chart: https://htmlcolorcodes.com/color-chart/material-design-color-chart/
# OpenGL intro: https://stackabuse.com/brief-introduction-to-opengl-in-python-with-pyopengl/
# CSV reader: https://docs.python.org/3/library/csv.html
# Circle examples: https://stackoverflow.com/questions/25423268/i-have-created-a-circle-from-lines-in-opengl-but-it-shows-holes-at-outer-edges
# Mouse with OpenGL: https://stackoverflow.com/questions/46801701/how-to-find-pygame-window-coordinates-of-an-opengl-vertice

# =============================================================================
# Imports
# =============================================================================
import pygame
from pygame.locals import *
from OpenGL.GL import *
from OpenGL.GLU import *
from OpenGL.GLUT import *
import math
import sys
import csv


# =============================================================================
# Global variables
# =============================================================================
position_debug=False

demo_mode=False
log_mode=False
factor=19*math.sqrt(2)
constants=[]

math_e=math.exp(1)
math_phi=(1+math.sqrt(5))/2
pi=math.pi

draw_help=False
after_help_zoom=-55
help_zoom=-30
default_zoom=help_zoom

zooming=True
zooming_complete=False
zoom_distance=default_zoom

mpos = [0,0]
viewPos = [0,0]
mouse_radial = [0,0]
mouse_hold_pos = [0,0]
mouse_button = [0,0,0]
prev_mouse_button =[0,0,0]

zoom_pos=[0,0,-100]
zoom_set=[0,0,default_zoom]

rotation = 0.0

yellow=[1,1,0]
white=[1,1,1]

help_state=0
help_scaling=0

# =============================================================================
# CSV Reader Function                                 
# ============================================================================= 

def read_csv():
  global constants
  constants=[]
  with open('constants.csv', 'r', newline='',encoding='utf16') as csvfile:
     reader = csv.DictReader(csvfile)

     #Read lines from the csv file
     for row in reader:
        const_name=row['description']
        log_const=float(row['log'])
        symbol=row['symbol'].strip()
        geo=row['geometry']
        print(const_name,log_const,geo,symbol,len(symbol))

        if geo and geo.isdigit():
           geometry=float(row['geometry'])
        else:
           geometry=0

        if log_mode==False:
            angle=2 * math.atan(log_const/factor)
            angle_deg=angle/math.pi*180
        else:
            angle_deg=log_const/factor
            if(const_name.find("+/- Infinity")!=-1):
                angle_deg=180

        #Colours based on angle of the constants
        const_colour=[0.2,0.2,0.2]
        if (int((angle_deg+0.001)/72)):
           const_colour[2]=0.1
        else:
           const_colour[2]=0.0
        if (int((angle_deg+0.001)/90)):
           const_colour[0]=0.5
        else:
           const_colour[0]=0

        #Find some keywords and add colours related to the constant type
        if (const_name.find("eed")!=-1):#"Speed"
           const_colour=[1,1,1]
        if (const_name.find("Electric")!=-1):
           const_colour=[1,0,1]
        if (const_name.find("Gravit")!=-1):
           const_colour=[0,1,1]
        if (const_name.find("Period")!=-1 or const_name.find("Frequency")!=-1 or int(angle_deg*10)==0):
           const_colour=[1,1,0]
        if (geometry>0):
           const_colour=[0.9,0.9,0.9]

        source=row['source']
        value=row['value']
        uncertainty=row['uncertainty']
        units=row['unit']
        category=row['category']
        subcategory=row['subcategory']

        #Create a list of constants
        const=(const_name,log_const,angle_deg,const_colour,geometry,symbol,source,value,uncertainty,units,category,subcategory)
        constants.append(const)

# =============================================================================
# Misc Functions
# =============================================================================

def angle_difference(a,b):
   while b<-180:
      b+=360
   return min(360 - abs(a - b), abs(a - b))

def angle_movement(a,b):
   while b<-180:
      b+=360
   diff=a-b
   if abs(diff)>90:
      diff=0
   return diff

# =============================================================================
# Constant List Modification Function
# =============================================================================

def adjust_factors():
    for idx in range(len(constants)):
        (const_name,log_const,angle_deg,const_colour,geometry,symbol,source,value,uncertainty,units,category,subcategory)= constants[idx]
        if log_mode==False:
            angle=2 * math.atan(log_const/factor)
            angle_deg=angle/math.pi*180
        else:
            angle_deg=log_const/factor
            if(const_name.find("+/- Infinity")!=-1):
                angle_deg=180
        constants[idx]=(const_name,log_const,angle_deg,const_colour,geometry,symbol,source,value,uncertainty,units,category,subcategory)

 
# =============================================================================
# 3D Text Printing Functions   
# =============================================================================



def drawText(x, y, text, pts):
    font = pygame.font.SysFont('arial', pts)
    textSurface = font.render(text, True, (255, 255, 66, 255)).convert_alpha()
    textData = pygame.image.tostring(textSurface, "RGBA", True)
    glWindowPos2d(x, y)
    glDrawPixels(textSurface.get_width(), textSurface.get_height(), GL_RGBA, GL_UNSIGNED_BYTE, textData)
 
def drawTextRadialHoriz(r,angle, text):
    x = r * math.cos(angle/180*math.pi)
    y = r * math.sin(angle/180*math.pi)
    textSurface = font.render(text, True, (255, 255, 66, 255)).convert_alpha()
    textData = pygame.image.tostring(textSurface, "RGBA", True)
    glRasterPos(x,y)
    glDrawPixels(textSurface.get_width(), textSurface.get_height(), GL_RGBA, GL_UNSIGNED_BYTE, textData)

def drawTextRadialPts(x, y, text, pts):
    font = pygame.font.SysFont('arial', pts)
    drawTextRadialHoriz(r,angle, text)

def label(x, y, s, angle, dir, scale,colour):
     glPushMatrix()
     glColor(colour)
     glTranslatef(x, y, 0.0)
     glScalef(scale, scale, scale)
     glRotatef(angle, 0, 0, 1);
     for c in s:
         glutStrokeCharacter(GLUT_STROKE_ROMAN, ord(c))
         width=glutStrokeWidth(GLUT_STROKE_ROMAN, ord(c))
     glPopMatrix()

def label_length(s):
     str_len=0
     for c in s:
        str_len+=glutStrokeWidth(GLUT_STROKE_ROMAN, ord(c))
     return str_len

def drawTextRadial(r,angle, text,scale,colour):
    text_angle=angle
    dir=0
    if (angle>90 or angle<-90):
         text_angle-=180
         dir=1
         len=label_length(text)
         r+=len*scale
    x = r * math.cos(angle/180*math.pi)
    y = r * math.sin(angle/180*math.pi)
    label(x, y, text, text_angle, dir, scale,colour)


# =============================================================================
# 3D Drawing Functions  
# =============================================================================

def draw_radial(r1,r2, h, num_slices,width,offset,colour,ang_width):
    n = float(num_slices)

    z = -h/2.0
    angle = offset/180*math.pi
    width1=ang_width/180*math.pi
    #angle-=width1/2 #centre the angle  y offsetting the rectangle
    for i in range(int(n)):
        angle = 2 * math.pi * (i/n)/width + offset/180*math.pi
        x1 = r1 * math.cos(angle + width1)
        y1 = r1 * math.sin(angle + width1)
        x2 = r1 * math.cos(angle)
        y2 = r1 * math.sin(angle)
        x3 = r2 * math.cos(angle)
        y3 = r2 * math.sin(angle)
        x4 = r2 * math.cos(angle + width1) 
        y4 = r2 * math.sin(angle + width1)

        glBegin(GL_QUADS)#draw a quadrangle for the radial arm
        glColor(colour)
        glVertex(x1, y1, z)
        glVertex(x2, y2, z)
        glVertex(x3, y3, z)
        glVertex(x4, y4, z)
        glVertex(x1, y1, z)
        glEnd()

def draw_circle(r1,r2, h, num_slices,width,offset,colour):
    n = float(num_slices)

    glBegin(GL_TRIANGLE_FAN)#draw the circle
    glColor(colour)
    z = -h/2.0
    for i in range(int(n) + 1):
        angle = 2 * math.pi * (i/n)
        x1 = r1 * math.cos(angle)
        y1 = r1 * math.sin(angle)
        x2 = r2 * math.cos(angle)
        y2 = r2 * math.sin(angle)
        glVertex(x2, y2, z)
    glEnd()


# =============================================================================
# Mouse Control
# =============================================================================

def check_mouse():
    global mpos, viewPos , mouse_radial, mouse_button, rotation, mouse_hold_pos, rotate, zoom_distance
    global prev_mouse_button
    changed=False
    newpos = pygame.mouse.get_pos()
    if (newpos[0]!=mpos[0] or newpos[1]!=mpos[1]):
       mpos=newpos
       #Scaling factor for mouse focus at a distance
       if(zoom_pos[0]==0 and zoom_pos[1]==0):
           z = 28 
       else:
           z = 31
       ndc = [ 2.0 * mpos[0]/width - 1.0, 1.0 - 2.0 * mpos[1]/height ]
       tanFov = math.tan( zoom_distance * 0.5 * math.pi / 180 )
       aspect = width / height
       viewPos = [z * ndc[0] * aspect * tanFov + zoom_set[0] , z * ndc[1] * tanFov +zoom_set[1]]
       mouse_ang=180*math.atan2(viewPos[0],-viewPos[1])/math.pi+90
       if (mouse_ang>180):
           mouse_ang=mouse_ang-360
       mouse_radial = [ math.sqrt(viewPos[0]*viewPos[0]+viewPos[1]*viewPos[1]) , mouse_ang ]
       changed=True
    
    mouse_button = pygame.mouse.get_pressed()
    #Ignore the initial mouse press
    if (mouse_button[0]==True and prev_mouse_button[0]==True):
       rotation-=angle_movement(mouse_radial[1],mouse_hold_pos[1])*5
       mouse_hold_pos=mouse_radial
       rotate=0
       changed=True
    else:
       mouse_hold_pos=mouse_radial
    if (mouse_button[2]==True):
       zoom_distance=zoom_distance+angle_movement(mouse_radial[1],mouse_hold_pos[1])/2
       if(zoom_distance>-8):
          zoom_distance=-8
       elif (zoom_distance<-99):
          zoom_distance=-99
       mouse_hold_pos=mouse_radial
       changed=True
    prev_mouse_button=mouse_button
    return changed

# =============================================================================
# Update screen
# =============================================================================

def update_zoom():
   global zoom_set , zoom_pos, zooming, mouse_radial, zooming_complete
   if (zoom_location==-1000):
        #move back far enough to see this object
        zoom_set=[0,0,default_zoom]
   else:
        zoom_radius=10
        zoom_angle=zoom_location
        zoom_set = [zoom_radius * math.cos(zoom_angle/180*math.pi) , zoom_radius * math.sin(zoom_angle/180*math.pi) , zoom_distance]

   zooming=False
   dist=0
   for dimension in range(3):
        if (zoom_pos[dimension]!=zoom_set[dimension]):
            zooming=True #Flag that we are still zooming
        zoom_pos[dimension]=(7*zoom_pos[dimension]+zoom_set[dimension])/8 #Weighted rolling averageÂ§
        dist+=abs(zoom_pos[dimension]-zoom_set[dimension]) #Add up amount of movement needed

   #Check if we are nearly at destination zoom position
   if dist<0.01:
       zoom_pos=zoom_set
       zooming_complete=True
   else:
       zomming_complete=False

   glTranslate(zoom_pos[0], zoom_pos[1], zoom_pos[2])



def update_display():
    global mpos, mouse_radial, viewPos, zooming_complete
    glClear(GL_COLOR_BUFFER_BIT)
    glClear(GL_DEPTH_BUFFER_BIT)
    glEnable(GL_DEPTH_TEST)

    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(30, float(width)/height, 1, 100)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    update_zoom()

    #TODO: This is the factor used for ATAN mode.
    #Needs a more meaningful display
    drawText(20,40,str(factor) ,14)
    drawText(20,20,str(zoom_distance) ,14)


    if (position_debug):
        drawText(920,70,str(round(mouse_radial[0],3)),14 )
        drawText(920,90,str(round(mouse_radial[1],2)),14 )
        drawText(920,110,str(mpos[0]),14 )
        drawText(920,130,str(mpos[1]),14 )
        drawText(920,150,str(viewPos[0]),14 )
        drawText(920,170,str(viewPos[1]),14 )

    if(log_mode==False):
       intensity=500
       #Draw geometric shapes for the ATAN scales to investigate angular alignments.
       draw_circle(1,8,0.1,3,360,5,[106/intensity,27/intensity,154/intensity])#TRIANGLE
       draw_circle(1,8,0.2,4,360,5,[0/intensity,150/intensity,136/intensity])#SQUARE
       draw_circle(1,8,0.3,5,360,5,[158/intensity,157/intensity,36/intensity])#PENTAGON
       draw_circle(1,8,0.4,7,360,5,[51/intensity, 105/intensity, 30/intensity])#HEPTAGON
    else:
     #Draw a pointer when in log mode
     glPushMatrix()
     glTranslatef(7, 0, 0.0)
     draw_circle(1,1,0.1,3,360,5,[1,1,1])#TRIANGLE
     glPopMatrix()

    draw_circle(1,8,0.4,7,360,5,[0.1,0,0.1])#Octagon Inner Background
    draw_circle(12,13.5,0.5,11,360,5,[0.1,0,0.1])#Hendecagon Outer Background


    slice=1
    hght=0.2
    wd=800
    overlap=0.05

    mouse_ang_width=0.6

    if (not log_mode):
        #Marker for 23 degrees which is maximum angle for polarisation entanglement
        draw_radial(12,13,hght,30,wd,23+120,[1,1,0],0.5)
        draw_radial(12,13,hght,30,wd,120,[1,1,0],0.5)
        #Marker for 23 degrees which is maximum angle for polarisation entanglement
        draw_radial(12,13,hght,30,wd,90,[1,1,0],0.5)
        draw_radial(12,13,hght,30,wd,90+23,[1,1,0],0.5)

    detail_offset=150

    for (const_name,log_const,angle_deg,const_colour,geometry,symbol,source,value,uncertainty,units,category,subcategory) in constants:
       if (disp_symbol==0 or ((disp_symbol==1 or disp_symbol==3) and len(symbol)>0)):
           draw_radial(8,10+overlap,hght,slice,wd,angle_deg-rotation/5,const_colour,0.5)
           draw_radial(10-overlap,12,hght,slice,wd,angle_deg,const_colour,0.5)
           draw_radial(9,10+overlap,hght,slice,wd,angle_deg-rotation/5,const_colour,0.5)

           #Detect mouse over constant
           draw_text=False
           if(mouse_radial[0]>=5 and mouse_radial[0]<10):
              if(angle_difference(mouse_radial[1],(angle_deg-rotation/5))<mouse_ang_width):
                 draw_text=True
           if(mouse_radial[0]>=10 and mouse_radial[0]<14):
              if(angle_difference(mouse_radial[1],angle_deg)<mouse_ang_width):
                 draw_text=True
           
           if (draw_text==True):
              drawText(20,detail_offset,value+ " " + units,20)
              if (symbol in const_name): 
                  symbol_disp="" 
              else: 
                  symbol_disp=symbol
              drawText(20,detail_offset+30,const_name+ "    " +symbol_disp,20) 
              drawText(20,detail_offset+60,"Source: " +source,12)
              detail_offset+=100


       #The horizontal text displayed at the geometrical points of the outer wheel
       if(geometry>0 and geometry<6):
          drawTextRadialHoriz(14,angle_deg, const_name) #Fast 
          # drawTextRadialPts(12.5,angle_deg, symbol,18) #Slow, shows utf-16
          # drawText(13.7,angle_deg, const_name) #Fast, but does not show utf-16
          rad_len=13.5
       else:
          rad_len=12

       #Text to display on start-up zoom setting
       if (zoom_location>-1000 or disp_symbol==3):
          text_offset=0.3
          if (disp_symbol!=0):
              drawTextRadial(12+text_offset,angle_deg, symbol,0.0015,yellow)
              drawTextRadial(10+text_offset,angle_deg-rotation/5,symbol,0.0015,yellow)

       if (disp_symbol==0 or ((disp_symbol==1 or disp_symbol==3) and len(symbol)>0) or rad_len==13.5):
          #Draw outer circle spokes
          draw_radial(10-overlap,rad_len,hght,slice,wd,angle_deg,const_colour,0.5)

    if(zooming_complete):
          help_display()

    pygame.display.flip()

# =============================================================================
# Help Banner
# =============================================================================

def request_help():
   global help_state, help_scaling 
   help_state=0
   help_scaling=100

def help_display():
   global help_state, help_scaling
   if (help_state>1):
      return True
   if (help_state==0):
      help_state+=1

   help_scaling-=10
   if (help_scaling)<0:
      help_scaling=0

   help_x=230+help_scaling
   help_y=590-(help_scaling*3)
   fs=int(18*(100-help_scaling)/100)
   vert_space=20
   drawText(help_x,help_y-0*vert_space,"Circular logarithmic slide rule for fundamental physical constants",fs+2)
   drawText(help_x,help_y-3*vert_space," z,x = rotate the inner slide rule wheel",fs)
   drawText(help_x,help_y-4*vert_space," c,d = zoom in/out",fs)
   drawText(help_x,help_y-5*vert_space," q = return to 0 degree rotation point",fs)
   drawText(help_x,help_y-6*vert_space," w = return to -180 degree rotation point",fs)
   drawText(help_x,help_y-7*vert_space," e = cancel zoom",fs)
   drawText(help_x,help_y-8*vert_space," 1,2,3,4,5,6,7,8,9,0 = zoom on sectors of the circular slide rule",fs)

   drawText(help_x,help_y-10*vert_space," f = display basic symbols",fs)
   drawText(help_x,help_y-11*vert_space," g = display all symbols",fs)
   drawText(help_x,help_y-12*vert_space," + = display basic symbols when not zoomed",fs)
   drawText(help_x,help_y-13*vert_space," a = natural log mode (LSPR mode)",fs)
   drawText(help_x,help_y-14*vert_space," s = arctangent natural log mode",fs)

   drawText(help_x,help_y-16*vert_space," r,t,y,u,i - experimental ARCTAN/LN scaling factors",fs)
   drawText(help_x,help_y-17*vert_space," v,b - demo modes",fs)

   drawText(help_x,help_y-19*vert_space," k,l = course adjust factor for ARCTAN scaling",fs)
   drawText(help_x,help_y-20*vert_space," n,m = fine adjust factor for ARCTAN scaling",fs)
   drawText(help_x,help_y-21*vert_space," h=help",fs)
   drawText(help_x,help_y-23*vert_space,"                         --------> Press Any Key To Continue... <--------",fs)


# =============================================================================
# Main Code
# =============================================================================

read_csv() # Read the fundamental constants into a list

pygame.init()
request_help()

(width, height) = (1080,800) #(800, 600)
screen = pygame.display.set_mode((width, height), OPENGL | DOUBLEBUF)
clock = pygame.time.Clock()
font = pygame.font.SysFont('arial', 12)
glEnable(GL_BLEND)
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

rotate=1
zoom_location=-1000
disp_symbol=1

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

    keypress = pygame.key.get_pressed()
    req_update=True

    prev_zoom_location=zoom_location

    if(help_state==1):
        #Check all keys to continue after help screen
        pressed=False
        for keys in keypress:
            if(keys==True):
                pressed=True
        if (pressed==True):
            help_state+=1
            default_zoom=after_help_zoom
            zoom_distance=default_zoom
            zoom_location=-1000
            mpos=[0,0] #Reset mouse position

    #TODO: This becomes a case statement in Python3.10
    if keypress[pygame.K_z]:
       rotation += 1.0
       rotate=0
    elif keypress[pygame.K_x]:
       rotation -= 1.0
       rotate=0
    elif keypress[pygame.K_q]:
       rotation = 0.0
       rotate=0
       zoom_distance=default_zoom
       zoom_location=-1000
    elif keypress[pygame.K_w]:
       rotation = 180.0*5
       rotate=0
       zoom_distance=default_zoom
       zoom_location=-1000
    elif keypress[pygame.K_e]:
       zoom_distance=default_zoom
       zoom_location=-1000
    elif keypress[pygame.K_s]:
       demo_mode=False
       factor=19*math.sqrt(2)
       log_mode=False
       adjust_factors()
    elif keypress[pygame.K_r]:
       if (log_mode):
          factor=1.0
       else:
          factor=9.5*math.sqrt(2)
       adjust_factors()
    elif keypress[pygame.K_t]:
       if (log_mode):
           factor=0.75    
       else:
           factor=19*math.sqrt(2)
       adjust_factors()
    elif keypress[pygame.K_y]:
       if (log_mode):
           factor=1/math.sqrt(2)
       else:
           factor=57.206
       adjust_factors()
    elif keypress[pygame.K_u]:
       if (log_mode):
           factor=1/math_phi
       else:
           factor=(30)*math.sqrt(5)
       adjust_factors()
    elif keypress[pygame.K_i]:
       if (log_mode):
           factor=0.5
       else:
          factor=82.37
       adjust_factors()
    elif keypress[pygame.K_a]:
       log_mode=True
       demo_mode=False
       factor=1.0
       adjust_factors()
    elif keypress[pygame.K_k]:
       factor+=0.1
       adjust_factors()
    elif keypress[pygame.K_l]:
       factor-=0.1
       adjust_factors()
    elif keypress[pygame.K_n]:
       factor+=0.01
       adjust_factors()
    elif keypress[pygame.K_m]:
       factor-=0.01
       adjust_factors()
    elif keypress[pygame.K_1]:
       zoom_location=0
    elif keypress[pygame.K_2]:
       zoom_location=30
    elif keypress[pygame.K_3]:
       zoom_location=-30
    elif keypress[pygame.K_4]:
       zoom_location=90
    elif keypress[pygame.K_5]:
       zoom_location=-90
    elif keypress[pygame.K_6]:
       zoom_location=120
    elif keypress[pygame.K_7]:
       zoom_location=-120
    elif keypress[pygame.K_8]:
       zoom_location=144
    elif keypress[pygame.K_9]:
       zoom_location=-144
    elif keypress[pygame.K_0]:
       zoom_location=180
    elif keypress[pygame.K_g]:
       disp_symbol=0
    elif keypress[pygame.K_f]:
       disp_symbol=1
    elif keypress[pygame.K_PLUS]:
       disp_symbol=3
    elif keypress[pygame.K_v]:
       demo_mode=True
       rotate=1
    elif keypress[pygame.K_b]:
       demo_mode=False
       rotate=0
    elif keypress[pygame.K_d]:
       if (zoom_location!=-1000):
          zoom_distance=zoom_distance+1
          if(zoom_distance>-8):
             zoom_distance=-8
       else:
          zoom_location=180
    elif keypress[pygame.K_c]:
       if (zoom_location!=-1000):
          zoom_distance=zoom_distance-1
          if(zoom_distance<-99):
             zoom_distance=-99
       else:
          zoom_location=180
    elif keypress[pygame.K_h]:
       request_help()
       zoom_distance=help_zoom
       default_zoom=help_zoom
       zoom_location=-1000
    else:
       #Only rotate if no keys pressed
       rotation += rotate
       if (int(rotate*1000)!=0):
         req_update=True
       else:
         req_update=False

    #Focus after a zoom change
    if (zoom_location!=prev_zoom_location):
        zoom_distance=-20
        mpos=[0,0]

    if (check_mouse()):
       req_update=True

    if (req_update or zooming):
       update_display()

    clock.tick(60)
    pygame.event.pump() # process event queue
